
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <math.h>
#include <ibase.h>
#include "example.h"
#include <stdio.h>

#include <psinfo/ps_utils.h>


#ifdef __LINUX__

    #define ARQUIVOCFG	"/etc/psfarma.dat"
    #define ARQUIVOLOG  "/tmp/logfirebird"

#else
    #define ARQUIVOCFG	"c:\\psfarma.dat"
    #define ARQUIVOLOG  "c:\\logfirebird.txt"
#endif /* __LINUX__*/


#define AJUSTEDADATA  3

int idloja=0;

typedef struct blob {
	short	(*blob_get_segment) ();
	void	*blob_handle;
	long	blob_number_segments;
	long	blob_max_segment;
	long	blob_total_length;
	void	(*blob_put_segment) ();
} *BLOB;




#if 0
#define LOGUDF(fase,msg) \
{ \
   fn_pslogfirebird(fase);\
   fn_pslogfirebird(msg);\
}
#else
#define LOGUDF(fase,msg)
#endif


long EXPORT fn_pssetidloja(ARG(int *, novoid))
ARGLIST(int* novoid)
{
    FILE* f;
    if(!novoid) return 1;
    f=fopen(ARQUIVOCFG,"w+");
    if(!f)return 1;
    idloja=*novoid<0?0:*novoid;
    fwrite(&idloja,1,sizeof(idloja),f);
    fclose(f);
    return 0;
}

long EXPORT fn_psidloja(void)
{
    if(idloja<1){
        FILE* f=fopen(ARQUIVOCFG,"r+");
        if(f){
            fread(&idloja,1,sizeof(idloja),f);
            fclose(f);
        }
    }
    return idloja;
}


long EXPORT fn_psmod(ARG(int *, l1),ARG(int *, l2))
ARGLIST(int* l1)
ARGLIST(int* l2)
{
    if(!l1||!l2)return 0;   
    return *l1%*l2;
}

/*
    Função que retorna 0 se senha é inválida ou
    1 se senha é válida

    Nome real da funcao ConfereSenha
*/

int EXPORT fn_psfnp1 (ARG(BLOB, b),ARG(char*,senha))
ARGLIST(BLOB b)
ARGLIST(char* senha)
{
    char *buf,*p,*s=senha;
	short length, actual_length;
    int l=0;
    int r=0;
	/* Valores nulos */
	if (!b->blob_handle||!senha)
		return 0;

    length=b->blob_max_segment+1;
	buf=(char*)malloc(length);
    while ((*b->blob_get_segment)(b->blob_handle, buf,length,&actual_length)){
	    buf[actual_length]=0;
        p=buf;
        while(*p){
            if(!*s||*p++!=*s++)
                goto erro;
            l++;
        }
    }
    if(l==strlen(senha))
        r=1;
  erro:
    free(buf);
    return r;
}

/*
  Função que criptografa a senha
  Nome real da funcao GeraSenha
*/

void EXPORT fn_psfnp2 (ARG(char*,novasenha),ARG(BLOB,destino))
ARGLIST(char* novasenha)
ARGLIST(BLOB destino)
{
	short length;
	/* Valores nulos */
	if (!destino->blob_handle||!novasenha)
		return;
    length=strlen(novasenha);
    if(!length)return;
    (*destino->blob_put_segment)(destino->blob_handle, novasenha,length);
    return;
}

long EXPORT fn_psdow (ARG(ISC_DATE*, a))
ARGLIST(ISC_DATE *a)
{
   if(a&&*a!=0)
      return ((*a+AJUSTEDADATA)%7)+1;
   else
      return 0;
}

int rndiniciado=0;

long EXPORT fn_psrandomize (void)
{
#ifndef __LINUX__
    randomize();
#endif
    return 1;
}

long EXPORT fn_psrandom (ARG(int* ,n))
ARGLIST(int*n)
{
    if(!rndiniciado){
        rndiniciado=1;
#ifndef __LINUX__
        randomize();
#endif
    }
#ifdef __LINUX__
    return 1+(int)(((double)*n)*rand()/(RAND_MAX+1.0));
#else
    return random(*n)+1;
#endif
}

char* EXPORT fn_psrua (ARG(char*, s))
ARGLIST(char *s)
{
    char tmp[31];
    char *buf;
    char*buffer;
    if(!s||!*s)return NULL;
    buffer=(char*)malloc(31);
    strncpy(tmp,s,sizeof(tmp)-1);
    tmp[30]=0;
    s=tmp;
    buf=buffer;
    while(*s&&*s!=','&&*s!='-')
        *buf++=*s++;
    *buf=0;
    return buffer;
}

char* EXPORT fn_pstelefonelimpo (ARG(char*, s))
ARGLIST(char *s)			/* VARCHAR input */
{
	char *buf;
	short length = 0;
	char *buffer;
	length=(short)*s;
    buffer=(char*)malloc(length+1);
    s+=2;
	buf=buffer;
	while (*s){
        if(*s>='0'&&*s<='9')
            *buf++=*s;
        s++;
    }
	*buf=0;
	return buffer;
}

char* EXPORT fn_formatar_cnpjcpf (ARG(char*, s))
ARGLIST(char *s)			/* VARCHAR input */
{
	char *buf;
	short length=0;
	char *buffer;
    if(!s)return s;
	length=(short)*s;
    if(length==0)return s;
    buffer=(char*)malloc(21);
    s+=2;
    return PSFormatar_CNPJCPF(s,buffer,21);
}

int EXPORT fn_cnpj_valido(ARG(char*, s))
ARGLIST(char *s)			/* VARCHAR input */
{
    return s?PSCNPJ_Valido(s+2):0;
}

int EXPORT fn_cpf_valido(ARG(char*, s))
ARGLIST(char *s)			/* VARCHAR input */
{
    return s?PSCPF_Valido(s+2):0;
}

char * EXPORT fn_ps_crypto(ARG(char*, s))
ARGLIST(char *s)			/* VARCHAR input */
{

/*select a.*, pscrypto(senha) from usuarios a*/
	short length=0;
	char *buffer;
    if(!s) return NULL;
	length=(short)*s;
    if(length<1){
        return NULL;
    }
    buffer=(char*)malloc(DIGESTLENDBL+11);
    s+=2;
    return PSCrypto(s,strlen(s),buffer,DIGESTLENDBL+1);
}

#if 0
int EXPORT fn_ps_cryptocmp(ARG(char*, s))
ARGLIST(char *s)			/* VARCHAR input */
{
/* retorna 0 se ok */
	short length=0;
    if(!s) return 1;
	length=(short)*s;
    if(length<1) return 1;
    s+=2;
    return PSCompareCrypto(s,strlen(s),buffer,DIGESTLENDBL+1);
}
#endif

ISC_UINT64 EXPORT fn_ps_testelargeint(ARG(ISC_UINT64*, s))
ARGLIST(ISC_UINT64 *s)			/* ISC_INT64 input */
{
    unsigned short *j;
    ISC_UINT64 r=0;
    if(!s)return r;
    r=*s;
    j=&r;
    j[3]=(unsigned short)(fn_psidloja());
    return r;
}

int EXPORT fn_pscmplarge(ARG(ISC_UINT64*, l), ARG(ISC_UINT64*, r) )
ARGLIST(ISC_UINT64 *l)
ARGLIST(ISC_UINT64 *r)
{
    if(l==r)return 1;
    if(!l)
        return 0;
    else if(!r)
        return 0;
    else
        return *r==*l;
}

int EXPORT fn_pscmpdate(ARG(ISC_DATE*, l), ARG(ISC_DATE*, r) )
ARGLIST(ISC_DATE *l)
ARGLIST(ISC_DATE *r)
{
    if(l==r)return 1;
    if(!l)
        return 0;
    else if(!r)
        return 0;
    else
        return *r==*l;
}

int EXPORT fn_pscmpstr(ARG(char*, l), ARG(char*, r) )
  ARGLIST(char *l)
    ARGLIST(char *r)
{
   
       if(l==r)return 1;
       if(!l)
             return 0;
       else if(!r)
             return 0;
       else
             return strcmp(l,r)==0;
}

int EXPORT fn_pscmptimestamp(ARG(ISC_TIMESTAMP*, l), ARG(ISC_TIMESTAMP*, r) )
  ARGLIST(ISC_TIMESTAMP *l)
    ARGLIST(ISC_TIMESTAMP *r)
{
   
       if(l==r)return 1;
       if(!l)
             return 0;
       else if(!r)
             return 0;
       else
          return r->timestamp_date==l->timestamp_date&&r->timestamp_time==l->timestamp_time;
}


int EXPORT fn_psperiodo(ARG(ISC_DATE*, data), ARG(ISC_DATE*, datainicial), ARG(ISC_LONG*, dias) )
ARGLIST(ISC_DATE *data)
ARGLIST(ISC_DATE *datainicial)
ARGLIST(ISC_LONG *dias)
{
	int d=dias?*dias:1;
    int diferenca;
    if(!data||!datainicial)return 0;
    diferenca=*data-*datainicial;
    if(d<1)
    	d=1;
    return (diferenca/d)+1;
}

char* EXPORT fn_pspad (ARG(char*, s),ARG(int*,tamanho))
ARGLIST(char *s)			/* VARCHAR input */
ARGLIST(int *tamanho)			/* VARCHAR input */
{
	char *buf;
	short length=0;
	char *buffer;
    int size;
    int x=0;
    if(!tamanho){
        buffer=malloc(1);
        *buffer=0;
        return buffer;
    }
    size=*tamanho;
    if(!s)return s;
    if(size<1){
        buffer=malloc(1);
        *buffer=0;
        return buffer;
    }
	length=(short)*s;
    buffer=(char*)malloc(size+1);
    buffer[0]=0;
    if(length==0)return buffer;
    s+=2;
    buf=s;
    x=strlen(buf);
    buffer[size]=0;
    while(size>0){
        if(x<1){
            while(size--)
                buffer[size]=' ';
        } else
            buffer[--size]=buf[--x];
    }
    return buffer;
}

char* EXPORT fn_psupper (ARG(char*, s)) ARGLIST(char *s){
	short length;
	char *buffer;
    if(!s)return s;
	length=(short)*s;
    s+=2;
    if(length<0)return NULL;
    buffer=(char*)malloc(length+5);
    buffer[length]=0;
    if(length==0)return buffer;
    PSUpperCase(0,s,buffer);
    return buffer;
}

int EXPORT fn_psuppertbl (ARG(int *, tabela), ARG(unsigned char*, entrada),ARG(unsigned char*, saida))
ARGLIST(int *tabela)
ARGLIST(unsigned char *entrada)
ARGLIST(unsigned char *saida)
{
    if(!entrada||!saida||!tabela)return 1;
	if((short)*entrada<1||(short)*saida<1)return 2;
    if(*tabela<0||*tabela>1)return 3;
    saida+=2;
    entrada+=2;
    PSGerarByteUpperCase(*tabela,*entrada,*saida);
    return 0;
}

int EXPORT fn_psuppercasechar (ARG(int *, tabela),ARG(unsigned int*, entrada))
ARGLIST(int *tabela)
ARGLIST(unsigned int *entrada){
    if(!entrada||!tabela)return 0;
    return PSUpperCaseChar(*tabela,*entrada);
}

double EXPORT fn_pscoeficiente (ARG(double *, vl1),ARG(double*, vl2))
ARGLIST(double *vl1)
ARGLIST(double *vl2){
	/*Objetivo:
    	calcular o coeficiente entre vl1 e vl2
    	VL1: Valor Base
        VL2: Valor p/ cálculo
    */
    if(!vl1||!vl2)
    	return 0.0;
    if(*vl1==0.00)
    	return 0.0;
    else
    	return (*vl2/(*vl1))*100.0;
}

double DiasPrioridades[]={
                1.0,
                3.0,
                6.0,
                12.0,
                20.0,
                30.0,
                45.0,
                55.0,
                60.0,
                70.0,
                80.0,
                90.0
        };
        
double EXPORT fn_psprioridade(ARG(int *, atraso),ARG(int*, prioridade))
ARGLIST(int *atraso)
ARGLIST(int *prioridade){
    /*
        Objetivo:
    	calcular um coeficiente de prioridade
    	atraso: Dias de Atraso
        prioridade: Nivel da prioridade (1 Maior / 4 Menor
    */
    double a;
    int p;
    if(!prioridade)
    	return 0.0;
    p=*prioridade;
    if(!atraso)
       a=0;
    else
       a=*atraso;
    if(p<1||p>10)
        p=1;
    if(a<0)
        a=0;
    return a/DiasPrioridades[p-1];
}

int EXPORT fn_psbitset(ARG(int *, valor),ARG(int*, bit))
ARGLIST(int *valor)
ARGLIST(int *bit){
    /*
        Objetivo:
    	calcular se o bit está ativo
    	atraso: Valor desejado
        prioridade: Bit (0 à 31)
        retorna: 1 se está ativo, 0 caso contrario
    */
    int v, b, p;
    if(!valor||!bit)
    	return 0;
    v=*valor;
    b=*bit;
    if(b<0||b>31)
       return 0;
    p=powl(2,b);
    return p&v;
}

int EXPORT fn_pscmpblob (ARG(BLOB, b1),ARG(BLOB, b2))
  ARGLIST(BLOB b1)
  ARGLIST(BLOB b2)
{
   char *buf1,buf2;
   char BufferLog[1024];
   long l1,l2,al1,al2;
   int r=1;
   int i;
   if(b1&&!b2)
     return 0;
   else if(!b1&&b2)
     return 0;
   else if(b1==b2)
     return 1;
   if(b1->blob_handle&&!b2->blob_handle)
     return 0;
   else if(!b1->blob_handle&&b2->blob_handle)
     return 0;
   else if(b1->blob_handle==b2->blob_handle){
        LOGUDF("fn_pscmpblob","Handle são iguais...");
        return 1;
   }	
   if(b1->blob_total_length!=b2->blob_total_length)
     return 0;
   l1=b1->blob_max_segment+1;
   l2=b2->blob_max_segment+1;
   buf1=(char*)malloc(l1); 
   LOGUDF("fn_pscmpblob","Inicio do WHILE...");
   al1=0;
   while ((*b1->blob_get_segment)(b1->blob_handle, buf1,l1,&al1))
     {
	sprintf(BufferLog, "1 - %u - %u",al1,l1);		
        LOGUDF("fn_pscmpblob",BufferLog);
	i=0;
	al2=0;
	while(i<al1&&(*b2->blob_get_segment)(b2->blob_handle, &buf2,1,&al2))
	  {
	     sprintf(BufferLog, "2 - %u - %u",al2, l2);
	     LOGUDF("fn_pscmpblob",BufferLog);
	     if(buf1[i++]!=buf2){
		LOGUDF("fn_pscmpblob","Valores diferentes...");
		r=0;
	        goto erro;
	     }
	  }
     }
   LOGUDF("fn_pscmpblob","Fim do WHILE...");   
   erro:
       free(buf1);
       return r;
}

int EXPORT fn_pslogfirebird (ARG(char*, s))
  ARGLIST(char *s)                        /* VARCHAR input */
{
   FILE* f=NULL;
   if(!s||!*s)return 0;
   f=fopen(ARQUIVOLOG,"a+");
   if(f){
      fprintf(f,"%s\n",s);
      fclose(f);
   }	   
   return 1;	   
}

/*fn_psidlojacodigo64:
 * Objetivo: Juntar dois numeros de 32 bits em 1 unico de 64 bits
 * N1 -> parte alta
 * N2 -> parte baixa
 * */
ISC_UINT64 *EXPORT fn_psidlojacodigo64(ARG(unsigned int*, n1), ARG(unsigned int*,n2))
  ARGLIST(unsigned int*n1)
  ARGLIST(unsigned int*n2){
     unsigned int *n;
     if(!n1||!n2)
       return NULL;
     n=(unsigned int*)malloc(sizeof(ISC_UINT64));     
     n[0]=*n2;
     n[1]=*n1;
     return n;     
}

/*fn_psidlojacodigo_int:
 *  * Objetivo: Juntar dois numeros de 32 bits em 1 unico de 32 bits
 *  * N1 -> parte alta  - 10 bits
 *  * N2 -> parte baixa - 22 bits
 *  * */
unsigned int *EXPORT fn_psidlojacodigo32(ARG(unsigned int*, n1), ARG(unsigned int*,n2))
    ARGLIST(unsigned int*n1)
      ARGLIST(unsigned int*n2)
{
   
        unsigned int *n;
        unsigned int x;
        if(!n1||!n2)
            return NULL;
        n=(unsigned int*)malloc(sizeof(unsigned int));
        *n=*n2&0x003fffff;
        x=*n1;
        x<<=22;
        *n|=x;
        return n;
}

char *EXPORT fn_psextrairnumeros(ARG(char*, c))
      ARGLIST(char *c)
{
   int l;
   char *d;
   if(!c)return c;
   l=strlen(c);
   d=(char*)malloc(l+1);
   strcpy(d,c);
   return Extrair_Numeros(d);
}



					
					
